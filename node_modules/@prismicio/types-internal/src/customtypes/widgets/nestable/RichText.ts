import { either } from "fp-ts/lib/Either"
import * as t from "io-ts"

import { StringOrNull } from "../../../validators"
import ImageConstraint from "../shared/ImageConstraint"
import WidgetTypes from "../WidgetTypes"

export const DEFAULT_OPTION = "paragraph"

export enum RichTextNodeType {
	heading1 = "heading1",
	heading2 = "heading2",
	heading3 = "heading3",
	heading4 = "heading4",
	heading5 = "heading5",
	heading6 = "heading6",
	paragraph = "paragraph",
	strong = "strong",
	em = "em",
	preformatted = "preformatted",
	hyperlink = "hyperlink",
	image = "image",
	embed = "embed",
	list = "list-item",
	orderedList = "o-list-item",
	rtl = "rtl",
}

export function parseRichTextNodeType(
	str: string,
): RichTextNodeType | undefined {
	switch (str) {
		case RichTextNodeType.heading1:
			return RichTextNodeType.heading1
		case RichTextNodeType.heading2:
			return RichTextNodeType.heading2
		case RichTextNodeType.heading3:
			return RichTextNodeType.heading3
		case RichTextNodeType.heading4:
			return RichTextNodeType.heading4
		case RichTextNodeType.heading5:
			return RichTextNodeType.heading5
		case RichTextNodeType.heading6:
			return RichTextNodeType.heading6
		case RichTextNodeType.paragraph:
			return RichTextNodeType.paragraph
		case RichTextNodeType.strong:
			return RichTextNodeType.strong
		case RichTextNodeType.em:
			return RichTextNodeType.em
		case RichTextNodeType.preformatted:
			return RichTextNodeType.preformatted
		case RichTextNodeType.hyperlink:
			return RichTextNodeType.hyperlink
		case RichTextNodeType.image:
			return RichTextNodeType.image
		case RichTextNodeType.embed:
			return RichTextNodeType.embed
		case RichTextNodeType.list:
			return RichTextNodeType.list
		case RichTextNodeType.orderedList:
			return RichTextNodeType.orderedList
		case RichTextNodeType.rtl:
			return RichTextNodeType.rtl
		default:
			return
	}
}

const RichTextOptions = new t.Type<string, string, unknown>(
	"RichTextOptions",
	(u: unknown): u is string => typeof u === "string",
	(u: unknown, context: t.Context) => {
		return either.chain(
			t.union([t.string, t.null]).validate(u, context),
			(s: string | null) => {
				if (!s) return t.success(DEFAULT_OPTION)
				const entries = s.split(",").map((e: string) => e.trim())
				const filtered = entries.filter((entry) => parseRichTextNodeType(entry))
				if (!filtered.length) return t.success(DEFAULT_OPTION)

				return t.success(filtered.join(","))
			},
		)
	},
	(a) => a,
)

const NoLabels = (
	labels:
		| string
		| string[]
		| {
				[x: string]: {
					name: string
				}[]
		  }
		| null,
) => {
	if (!labels) return t.success([])
	return
}

const LabelsAsObject = (
	labels:
		| string
		| string[]
		| {
				[x: string]: {
					name: string
				}[]
		  }
		| null,
) => {
	if (labels instanceof Object) {
		const labelsObj = labels as { [x: string]: { name: string }[] }

		// empty labels
		if (!Object.entries(labelsObj).length) return t.success([])

		// weird case labels with empty key as parent
		if (labelsObj[""]) {
			return t.success(labelsObj[""].map((l) => l.name))
		}

		const convertedObjectToArray = Object.entries(labelsObj)
			.reduce<ReadonlyArray<string>>((acc, [, labelsEntries]) => {
				return acc.concat(labelsEntries.map((l) => l.name))
			}, [])
			.filter(Boolean)

		return t.success(convertedObjectToArray)
	}
	return
}

const LabelsAsArray = (
	labels:
		| string
		| string[]
		| {
				[x: string]: {
					name: string
				}[]
		  }
		| null,
) => {
	if (labels instanceof Array) {
		const isValidLabels = labels.reduce(
			(acc, l) => acc && typeof l === "string",
			true,
		)
		if (isValidLabels) return t.success(labels)
	}
	return
}

const LabelsAsString = (
	labels:
		| string
		| string[]
		| {
				[x: string]: {
					name: string
				}[]
		  }
		| null,
) => {
	if (typeof labels === "string") {
		return t.success([labels])
	}
	return
}

const RichTextLabels = new t.Type<Array<string>, object, unknown>(
	"RichTextLabels",
	(u: unknown): u is Array<string> => {
		return u instanceof Array
	},
	(u: unknown, context: t.Context) => {
		const legacyValidator = t.record(
			t.string,
			t.array(t.record(t.literal("name"), t.string)),
		)
		const validator = t.array(t.string)

		return either.chain(
			t
				.union([legacyValidator, validator, t.string, t.null])
				.validate(u, context),
			(labels) => {
				return (
					NoLabels(labels) ||
					LabelsAsArray(labels) ||
					LabelsAsObject(labels) ||
					LabelsAsString(labels) ||
					t.failure(u, context)
				)
			},
		)
	},
	(res) => res,
)

export const RichTextConfig = t.exact(
	t.partial({
		label: StringOrNull,
		placeholder: t.string,
		useAsTitle: t.boolean,
		single: RichTextOptions,
		multi: RichTextOptions,
		imageConstraint: ImageConstraint,
		labels: RichTextLabels,
		allowTargetBlank: t.boolean,
	}),
)
export type RichTextConfig = t.TypeOf<typeof RichTextConfig>

export const RichText = t.exact(
	t.intersection([
		t.type({
			type: t.literal(WidgetTypes.RichText),
		}),
		t.partial({
			fieldset: StringOrNull,
			config: RichTextConfig,
		}),
	]),
)
export type RichText = t.TypeOf<typeof RichText>

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RichText = exports.RichTextConfig = exports.parseRichTextNodeType = exports.RichTextNodeType = exports.DEFAULT_OPTION = void 0;
const tslib_1 = require("tslib");
const Either_1 = require("fp-ts/lib/Either");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const validators_1 = require("../../../validators");
const ImageConstraint_1 = (0, tslib_1.__importDefault)(require("../shared/ImageConstraint"));
const WidgetTypes_1 = (0, tslib_1.__importDefault)(require("../WidgetTypes"));
exports.DEFAULT_OPTION = "paragraph";
var RichTextNodeType;
(function (RichTextNodeType) {
    RichTextNodeType["heading1"] = "heading1";
    RichTextNodeType["heading2"] = "heading2";
    RichTextNodeType["heading3"] = "heading3";
    RichTextNodeType["heading4"] = "heading4";
    RichTextNodeType["heading5"] = "heading5";
    RichTextNodeType["heading6"] = "heading6";
    RichTextNodeType["paragraph"] = "paragraph";
    RichTextNodeType["strong"] = "strong";
    RichTextNodeType["em"] = "em";
    RichTextNodeType["preformatted"] = "preformatted";
    RichTextNodeType["hyperlink"] = "hyperlink";
    RichTextNodeType["image"] = "image";
    RichTextNodeType["embed"] = "embed";
    RichTextNodeType["list"] = "list-item";
    RichTextNodeType["orderedList"] = "o-list-item";
    RichTextNodeType["rtl"] = "rtl";
})(RichTextNodeType = exports.RichTextNodeType || (exports.RichTextNodeType = {}));
function parseRichTextNodeType(str) {
    switch (str) {
        case RichTextNodeType.heading1:
            return RichTextNodeType.heading1;
        case RichTextNodeType.heading2:
            return RichTextNodeType.heading2;
        case RichTextNodeType.heading3:
            return RichTextNodeType.heading3;
        case RichTextNodeType.heading4:
            return RichTextNodeType.heading4;
        case RichTextNodeType.heading5:
            return RichTextNodeType.heading5;
        case RichTextNodeType.heading6:
            return RichTextNodeType.heading6;
        case RichTextNodeType.paragraph:
            return RichTextNodeType.paragraph;
        case RichTextNodeType.strong:
            return RichTextNodeType.strong;
        case RichTextNodeType.em:
            return RichTextNodeType.em;
        case RichTextNodeType.preformatted:
            return RichTextNodeType.preformatted;
        case RichTextNodeType.hyperlink:
            return RichTextNodeType.hyperlink;
        case RichTextNodeType.image:
            return RichTextNodeType.image;
        case RichTextNodeType.embed:
            return RichTextNodeType.embed;
        case RichTextNodeType.list:
            return RichTextNodeType.list;
        case RichTextNodeType.orderedList:
            return RichTextNodeType.orderedList;
        case RichTextNodeType.rtl:
            return RichTextNodeType.rtl;
        default:
            return;
    }
}
exports.parseRichTextNodeType = parseRichTextNodeType;
const RichTextOptions = new t.Type("RichTextOptions", (u) => typeof u === "string", (u, context) => {
    return Either_1.either.chain(t.union([t.string, t.null]).validate(u, context), (s) => {
        if (!s)
            return t.success(exports.DEFAULT_OPTION);
        const entries = s.split(",").map((e) => e.trim());
        const filtered = entries.filter((entry) => parseRichTextNodeType(entry));
        if (!filtered.length)
            return t.success(exports.DEFAULT_OPTION);
        return t.success(filtered.join(","));
    });
}, (a) => a);
const NoLabels = (labels) => {
    if (!labels)
        return t.success([]);
    return;
};
const LabelsAsObject = (labels) => {
    if (labels instanceof Object) {
        const labelsObj = labels;
        // empty labels
        if (!Object.entries(labelsObj).length)
            return t.success([]);
        // weird case labels with empty key as parent
        if (labelsObj[""]) {
            return t.success(labelsObj[""].map((l) => l.name));
        }
        const convertedObjectToArray = Object.entries(labelsObj)
            .reduce((acc, [, labelsEntries]) => {
            return acc.concat(labelsEntries.map((l) => l.name));
        }, [])
            .filter(Boolean);
        return t.success(convertedObjectToArray);
    }
    return;
};
const LabelsAsArray = (labels) => {
    if (labels instanceof Array) {
        const isValidLabels = labels.reduce((acc, l) => acc && typeof l === "string", true);
        if (isValidLabels)
            return t.success(labels);
    }
    return;
};
const LabelsAsString = (labels) => {
    if (typeof labels === "string") {
        return t.success([labels]);
    }
    return;
};
const RichTextLabels = new t.Type("RichTextLabels", (u) => {
    return u instanceof Array;
}, (u, context) => {
    const legacyValidator = t.record(t.string, t.array(t.record(t.literal("name"), t.string)));
    const validator = t.array(t.string);
    return Either_1.either.chain(t
        .union([legacyValidator, validator, t.string, t.null])
        .validate(u, context), (labels) => {
        return (NoLabels(labels) ||
            LabelsAsArray(labels) ||
            LabelsAsObject(labels) ||
            LabelsAsString(labels) ||
            t.failure(u, context));
    });
}, (res) => res);
exports.RichTextConfig = t.exact(t.partial({
    label: validators_1.StringOrNull,
    placeholder: t.string,
    useAsTitle: t.boolean,
    single: RichTextOptions,
    multi: RichTextOptions,
    imageConstraint: ImageConstraint_1.default,
    labels: RichTextLabels,
    allowTargetBlank: t.boolean,
}));
exports.RichText = t.exact(t.intersection([
    t.type({
        type: t.literal(WidgetTypes_1.default.RichText),
    }),
    t.partial({
        fieldset: validators_1.StringOrNull,
        config: exports.RichTextConfig,
    }),
]));

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Block = exports.TextBlock = exports.checkEmbedBlock = exports.EmbedBlock = exports.EmbedBlockType = exports.checkImageBlock = exports.ImageBlock = exports.ImageBlockType = exports.ValidatedMetas = exports.Span = exports.Meta = void 0;
const tslib_1 = require("tslib");
const E = (0, tslib_1.__importStar)(require("fp-ts/lib/Either"));
const t = (0, tslib_1.__importStar)(require("io-ts"));
const validators_1 = require("../../../../validators");
const function_1 = require("../../../../validators/function");
const EmbedContent_1 = require("../EmbedContent");
const ImageContent_1 = require("../ImageContent");
const Link_1 = require("../Link");
exports.Meta = t.exact(t.intersection([
    t.partial({
        data: t.unknown,
    }),
    t.type({
        start: t.number,
        end: t.number,
        type: t.string,
    }),
]));
// export alias for code clarity
exports.Span = exports.Meta;
exports.ValidatedMetas = new t.Type("ValidatedMetas", (metas) => Array.isArray(metas) && metas.every(exports.Meta.is), (metas, c) => {
    if (Array.isArray(metas)) {
        const res = metas
            .reduce((acc, maybeMeta) => {
            const maybeDecodedMeta = exports.Meta.decode(maybeMeta);
            if (E.isRight(maybeDecodedMeta)) {
                const meta = maybeDecodedMeta.right;
                // if it's an hyperlink it should have data validated as link otherwise we don't care and keep the meta
                if ((meta.data &&
                    meta.type === "hyperlink" &&
                    E.isRight(Link_1.Link.validate(meta.data, c))) ||
                    meta.type !== "hyperlink") {
                    return [...acc, meta];
                }
            }
            return acc;
        }, [])
            .sort((m1, m2) => m1.start - m2.start);
        return t.success(res);
    }
    else
        return t.failure(metas, c);
}, (m) => t.array(exports.Meta).encode(m));
exports.ImageBlockType = "image";
exports.ImageBlock = t.exact(t.intersection([
    t.type({
        type: t.literal(exports.ImageBlockType),
        data: t.intersection([
            ImageContent_1.ImageContentView,
            t.partial({
                linkTo: (0, function_1.nullable)(Link_1.Link),
            }),
        ]),
    }),
    t.partial({
        label: validators_1.StringOrNull,
        direction: validators_1.StringOrNull,
    }),
]));
function checkImageBlock(block) {
    return block.type === exports.ImageBlockType;
}
exports.checkImageBlock = checkImageBlock;
exports.EmbedBlockType = "embed";
exports.EmbedBlock = t.exact(t.intersection([
    t.type({
        type: t.literal(exports.EmbedBlockType),
        data: EmbedContent_1.EmbedContent,
    }),
    t.partial({
        label: validators_1.StringOrNull,
        direction: validators_1.StringOrNull,
    }),
]));
function checkEmbedBlock(block) {
    return block.type === exports.EmbedBlockType;
}
exports.checkEmbedBlock = checkEmbedBlock;
exports.TextBlock = t.exact(t.intersection([
    t.type({
        type: (0, function_1.refineType)(t.string, `string which isn't ${exports.ImageBlockType} ${exports.EmbedBlockType}`, (s) => s !== exports.ImageBlockType && s !== exports.EmbedBlockType),
        content: t.intersection([
            t.type({
                text: t.string,
            }),
            t.partial({
                spans: exports.ValidatedMetas,
            }),
        ]),
    }),
    t.partial({
        label: t.string,
        direction: t.string,
    }),
]));
exports.Block = t.union([exports.ImageBlock, exports.EmbedBlock, exports.TextBlock]);
